---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Swagger2Tex">
    <h1 class="text-center font-bold text-4xl">Swagger2Tex</h1>

    <form
        id="convert-form"
        class="flex flex-col justify-center items-center h-3/4 space-y-4"
    >
        <textarea
            id="swagger-input"
            class="w-4/5 h-full bg-transparent border-white border-4 rounded-xl outline-none p-2"
        ></textarea>
        <button type="submit" class="p-2 bg-red-600 rounded-md font-bold">
            Generate
        </button>
        <div
            id="swagger-output"
            class="w-4/5 h-full p-2 m-2 rounded-md border-4 border-white overflow-scroll select-all"
        >
        </div>

        <button
            type="button"
            id="download-result"
            class="hidden p-2 bg-green-600 rounded-md font-bold"
        >
            Download
        </button>
    </form>
</Layout>

<script lang="ts">
    const input = document.getElementById("swagger-input");
    const form = document.getElementById("convert-form");
    const output = document.getElementById("swagger-output");
    const download = document.getElementById("download-result");

    form.addEventListener("submit", (e) => {
        e.preventDefault();
        const swagger = input.value;
        let json;
        try {
            json = JSON.parse(swagger);
        } catch (e) {
            // TODO: show error
            console.error(e);
            return;
        }
        // TODO: Validate schema?
        console.log(json);
        const { components, paths } = json;
        const { schemas } = components;

        let groupsMap = {};

        for (const path in paths) {
            const methods = paths[path];
            for (const method in methods) {
                const group = methods[method].tags[0];
                if (!groupsMap[group]) {
                    groupsMap[group] = [];
                }
                groupsMap[group].push({ method, path, data: methods[method] });
            }
        }

        let tex = "";
        for (const groupKey in groupsMap) {
            tex += `\n\n\n\\makeendpointgroup{${groupKey}}\n`;
            const groups = groupsMap[groupKey];
            for (const group of groups) {
                const { method, path, data } = group;
                const { summary, description, parameters, responses } = data;
                tex += `\n\n\\makeendpoint{${method.toUpperCase()}}{${path}}{${summary}}\n`;
                if (parameters) {
                    tex += `\n\\begin{makeparameters}\n`;
                    for (const parameter of parameters) {
                        const {
                            name,
                            in: location,
                            description,
                            required,
                        } = parameter;
                        tex += `\\makeparameter{${name}}{${location}}{${description}}{${required}}\n`;
                    }
                    tex += `\\end{makeparameters}\n`;
                }
                if (responses) {
                    tex += `\\begin{makeresponses}\n`;
                    for (const responseKey in responses) {
                        const { description, content } = responses[responseKey];
                        tex += `\\makeresponse{${responseKey}}{${description}}\n`;
                        if (content) {
                            for (const contentType in content) {
                                const { schema } = content[contentType];
                                const { $ref, type } = schema;
                                if ($ref) {
                                    const schemaName = $ref.split("/").pop();
                                    const schemaData = schemas[schemaName];
                                    const { type, properties, required } =
                                        schemaData;
                                    tex += `\\makecontent{${contentType}}{${type}}\n`;
                                    if (properties) {
                                        tex += `\\begin{makeproperties}\n`;
                                        for (const propertyKey in properties) {
                                            const { type } =
                                                properties[propertyKey];
                                            tex += `\\makeproperty{${propertyKey}}{${type}}{${required.includes(
                                                propertyKey
                                            )}}\n`;
                                        }
                                        tex += `\\end{makeproperties}\n`;
                                    }
                                } else if (type) {
                                    tex += `\\makecontent{${contentType}}{${type}}\n`;
                                }
                            }
                        }
                    }
                    tex += `\\end{makeresponses}\n`;
                }
            }
        }
        tex = tex.trim().replace(/_/g, "\\_");
        output.innerText = tex;
        download.classList.remove("hidden");
        download.addEventListener("click", () => {
            const blob = new Blob([tex], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "swagger.tex";
            a.click();
        });
    });
</script>
